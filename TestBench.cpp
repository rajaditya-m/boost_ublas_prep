#define BOOST_TEST_MODULE GaussTest
#include <boost\test\unit_test.hpp>
#include <boost\exception\exception.hpp>
#include <boost\numeric\ublas\matrix.hpp>
#include <boost\numeric\ublas\gauss_elimination.hpp>

//Floating point matrix testing modules
#define CHECK_MATRICES_WITH_TOLERANCE(aa,bb,tolerance) { \
	auto ita1 = aa.begin1(), itb1 = bb.begin1(); \
	auto itae1 = aa.end1(); \
	for (; ita1 != itae1; ++ita1, ++itb1) { \
		auto ita2 = ita1.begin(), itb2 = itb1.begin(); \
		auto itae2 = ita1.end() ; \
		for(; ita2 !=itae2;++ita2, ++itb2) { \
			BOOST_CHECK_CLOSE(*ita2,*itb2,tolerance); \
		}\
	} \
} \


//We create two suites of test case 
//One which is positive and the other which is negative 

BOOST_AUTO_TEST_SUITE(PositiveTests)

BOOST_AUTO_TEST_CASE(fiedler5x5) {

	boost::numeric::ublas::matrix<double> M(5, 5);
	M(0, 0) = 0; M(0, 1) = 1; M(0, 2) = 2; M(0, 3) = 3; M(0, 4) = 4;
	M(1, 0) = 1; M(1, 1) = 0; M(1, 2) = 1; M(1, 3) = 2; M(1, 4) = 3;
	M(2, 0) = 2; M(2, 1) = 1; M(2, 2) = 0; M(2, 3) = 1; M(2, 4) = 2;
	M(3, 0) = 3; M(3, 1) = 2; M(3, 2) = 1; M(3, 3) = 0; M(3, 4) = 1;
	M(4, 0) = 4; M(4, 1) = 3; M(4, 2) = 2; M(4, 3) = 1; M(4, 4) = 0;

	boost::numeric::ublas::matrix<double> E(5, 5);
	E(0, 0) = 4; E(0, 1) = 3; E(0, 2) = 2; E(0, 3) = 1; E(0, 4) = 0;
	E(1, 0) = 0; E(1, 1) = 1; E(1, 2) = 2; E(1, 3) = 3; E(1, 4) = 4;
	E(2, 0) = 0; E(2, 1) = 0; E(2, 2) = 2; E(2, 3) = 4; E(2, 4) = 6;
	E(3, 0) = 0; E(3, 1) = 0; E(3, 2) = 0; E(3, 3) = 2; E(3, 4) = 4;
	E(4, 0) = 0; E(4, 1) = 0; E(4, 2) = 0; E(4, 3) = 0; E(4, 4) = 2;

	BOOST_CHECK(boost::numeric::ublas::gauss_elimination(M) == 0);
	CHECK_MATRICES_WITH_TOLERANCE(M, E, 1.0e-2);
}

BOOST_AUTO_TEST_CASE(random3x3) {
	boost::numeric::ublas::matrix<double> M(3, 3);
	M(0, 0) = 0.8147;  M(0, 1) = 0.9134; M(0, 2) = 0.2785;
	M(1, 0) = 0.9058;  M(1, 1) = 0.6324; M(1, 2) = 0.5469;
	M(2, 0) = 0.1270;  M(2, 1) = 0.0975; M(2, 2) = 0.9575;

	boost::numeric::ublas::matrix<double> E(3, 3);
	E(0, 0) = 0.9058;  E(0, 1) = 0.6324; E(0, 2) = 0.5469;
	E(1, 0) = 0;       E(1, 1) = 0.3446; E(1, 2) = -0.2134;
	E(2, 0) = 0;       E(2, 1) = 0;      E(2, 2) = 0.8863;

	BOOST_CHECK(boost::numeric::ublas::gauss_elimination(M) == 0);
	CHECK_MATRICES_WITH_TOLERANCE(M,E,1.0e-2);
}

BOOST_AUTO_TEST_CASE(tri4x4) {
	boost::numeric::ublas::matrix<double> M(4, 4);
	M(0, 0) = 1; M(0, 1) = 0.06; M(0, 2) = 0.06; M(0, 3) = 0; 
	M(1, 0) = 0; M(1, 1) = 1;    M(1, 2) = 0.06; M(1, 3) = 0.06; 
	M(2, 0) = 0; M(2, 1) = 0;    M(2, 2) = 1;    M(2, 3) = 0.06; 
	M(3, 0) = 0; M(3, 1) = 0;    M(3, 2) = 0;    M(3, 3) = 1; 

	boost::numeric::ublas::matrix<double> E(4, 4);
	E(0, 0) = 1; E(0, 1) = 0.06; E(0, 2) = 0.06; E(0, 3) = 0;
	E(1, 0) = 0; E(1, 1) = 1;    E(1, 2) = 0.06; E(1, 3) = 0.06;
	E(2, 0) = 0; E(2, 1) = 0;    E(2, 2) = 1;    E(2, 3) = 0.06;
	E(3, 0) = 0; E(3, 1) = 0;    E(3, 2) = 0;    E(3, 3) = 1;

	BOOST_CHECK(boost::numeric::ublas::gauss_elimination(M) == 0);
	CHECK_MATRICES_WITH_TOLERANCE(M, E, 1.0e-2);
}

BOOST_AUTO_TEST_CASE(randhess10x10) {
	double dataArray[100] = { -0.0116136237288931, 0.952038371026523, -0.264324306016915, -0.0202422199658613, -0.130318020105407, 0.0454282495045489, 0.0295919866949213, 0.0556917129821032, 0.0136785389204851, 0.000332266315006484,
		0.999932559597838, 0.0110573611294517, -0.00306997007249755, -0.000235101381452713, -0.00151356652613374, 0.000527622179460076, 0.000343693377684838, 0.000646826221612170, 0.000158868118313323, 3.85907621792327e-06,
		0, -0.305778800537279, -0.823081348506124, -0.0630323936429534, -0.405798215606182, 0.141459351301896, 0.0921466991850248, 0.173418823689230, 0.0425937002537554, 0.00103464645661908,
		0	,0 ,-0.502653290324226	,0.113859833725982	,0.733021779514561 ,-0.255527948207941 ,-0.166451045902457 ,-0.313258584816864 ,-0.0769399882882136 ,-0.00186895446463810,
		0	,0	,0 ,-0.991288582035386	,0.112659879971090 ,-0.0392727048211720 ,-0.0255822615050427 ,-0.0481454651848859 ,-0.0118250918155086 ,-0.000287244105894099,
		0	,0	,0	,0	,0.518005360170358	,0.492382704111741	,0.320738364075090	,0.603625200922546	,0.148257440148376	,0.00360133151623538,
		0	,0	,0	,0	,0 ,-0.817708776229847	,0.263960854912911	,0.496770707620092	,0.122012721370629	,0.00296381927553808,
		0	,0	,0	,0	,0	,0	,0.888664361908342 ,-0.445315361997851 ,-0.109374684038449 ,-0.00265682785505904,
		0	,0	,0	,0	,0	,0	,0	,0.238588995476406, -0.970834255774277, -0.0235826006361753,
		0	,0	,0	,0	,0	,0	,0	,0	,0.0242839043289716, - 0.999705102513007 };

	boost::numeric::ublas::matrix<double> M(10, 10);
	for (int r = 0; r < 10; r++) {
		for (int c = 0; c < 10; c++){
			M(r, c) = dataArray[r * 10 + c];
		}
	}

	double checkArray[100] = { 0.999932559597838, 0.0110573611294517, -0.00306997007249755, -0.000235101381452713, -0.00151356652613374, 0.000527622179460076, 0.000343693377684838, 0.000646826221612170, 0.000158868118313323, 3.85907621792327e-06,
		0, 0.952166795719128, -0.264359961898843, -0.0202449505289939, -0.130335599283077	,0.0454343775232882	,0.0295959784896961	,0.0556992254851052	,0.0136803840794720	,0.000332311135888359,
		0	,0 ,-0.907977894387518 ,-0.0695338561152054 ,-0.447654183904244	,0.156050145188735	,0.101651150342105	,0.191306070373597	,0.0469870181614135	,0.00114136483935829,
		0	,0	,0 ,-0.991288582035386	,0.112659879971090 ,-0.0392727048211720 ,-0.0255822615050427 ,-0.0481454651848859 ,-0.0118250918155086 ,-0.000287244105894099,
		0	,0	,0	,0	,0.998156490410587 ,-0.347952662680728 ,-0.226656555707248 ,-0.426564528299363 ,-0.104769259015543 ,-0.00254495716402286,
		0	,0	,0	,0	,0 ,-0.817708776229847	,0.263960854912911	,0.496770707620092	,0.122012721370629	,0.00296381927553808,
		0	,0	,0	,0	,0	,0	,0.888664361908342 ,-0.445315361997851 ,-0.109374684038449 ,-0.00265682785505904,
		0	,0	,0	,0	,0	,0	,0	,1.56235241636071	,0.383732106454897	,0.00932126257801535,
		0	,0	,0	,0	,0	,0	,0	,0 ,-1.02943451577476 ,-0.0250060635193069,
		0	,0	,0	,0	,0	,0	,0	,0	,0 ,-1.00029498447717 };
	boost::numeric::ublas::matrix<double> E(10, 10);
	for (int r = 0; r < 10; r++) {
		for (int c = 0; c < 10; c++){
			E(r, c) = checkArray[r * 10 + c];
		}
	}

	BOOST_CHECK(boost::numeric::ublas::gauss_elimination(M) == 0);
	CHECK_MATRICES_WITH_TOLERANCE(M, E, 1.0e-2);

}

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE(NegativeTests)

BOOST_AUTO_TEST_CASE(singular3x3) {
	boost::numeric::ublas::matrix<double> M(3, 3);
	//Create a matrix 
	M(0, 0) = 0; M(0, 1) = 1; M(0, 2) = 0;
	M(1, 0) = 2; M(1, 1) = 0; M(1, 2) = 2;
	M(2, 0) = 0; M(2, 1) = 1; M(2, 2) = 0;

	BOOST_CHECK_THROW(boost::numeric::ublas::gauss_elimination(M),boost::numeric::ublas::singular);
}

BOOST_AUTO_TEST_SUITE_END()